<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为twikoo评论系统设置二级域名</title>
      <link href="/2026/02/08/%E4%B8%BAtwikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
      <url>/2026/02/08/%E4%B8%BAtwikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景信息"><a href="#0-背景信息" class="headerlink" title="0.背景信息"></a>0.背景信息</h1><hr><p>Twikoo 是一个轻量级的静态网站评论系统。部署到 Vercel 后，默认域名 <code>*.vercel.app</code> 在中国大陆访问经常受限（需科学上网）。为改善访问体验，推荐为 Twikoo 绑定自己域名的二级子域。</p><h2 id="1-在-Vercel-为-Twikoo-添加二级域名"><a href="#1-在-Vercel-为-Twikoo-添加二级域名" class="headerlink" title="1. 在 Vercel 为 Twikoo 添加二级域名"></a>1. 在 Vercel 为 Twikoo 添加二级域名</h2><hr><ol><li>登录 Vercel 控制台，进入你的 Twikoo 项目</li><li>左侧菜单 → <strong>Settings</strong> → <strong>Domains</strong></li><li>在「Add Domain」处输入你想使用的二级域名，例如：<code>twikoo.example.com</code></li><li>点击 <strong>Add</strong>，此时状态会显示 <strong>Invalid Configuration</strong>（因为 DNS 尚未解析，属于正常现象）</li></ol><p><img src="/pics/2026-2/vercelTwikoo.png"></p><h2 id="2-在域名服务商处添加-DNS-解析记录"><a href="#2-在域名服务商处添加-DNS-解析记录" class="headerlink" title="2. 在域名服务商处添加 DNS 解析记录"></a>2. 在域名服务商处添加 DNS 解析记录</h2><hr><p>以阿里云为例：</p><ol><li><p>登录阿里云控制台 → <a href="https://dnsnext.console.aliyun.com/authoritative/domains/">域名控制台 - 公网权威解析</a></p></li><li><p>找到你的主域名，点击「解析设置」或「添加记录」</p></li><li><p>添加一条记录，参数如下（根据 Vercel 页面提示填写）：</p><ul><li><strong>记录类型</strong>：CNAME（推荐）  </li><li><strong>主机记录</strong>：twikoo（即你刚才填的子域名前缀）  </li><li><strong>记录值</strong>：Vercel 提供的目标地址（通常为 <code>cname.vercel-dns.com</code> 或类似格式）  </li><li><strong>TTL</strong>：默认（600 或 3600 均可）</li></ul></li><li><p>保存记录，等待 DNS 生效（通常 5–30 分钟，视运营商而定）</p></li></ol><h2 id="3-返回-Vercel-刷新并等待证书生成"><a href="#3-返回-Vercel-刷新并等待证书生成" class="headerlink" title="3. 返回 Vercel 刷新并等待证书生成"></a>3. 返回 Vercel 刷新并等待证书生成</h2><hr><ol><li>返回 Vercel 项目 → Domains 页面</li><li>点击刚才添加的域名旁边的 <strong>Refresh</strong> 按钮</li><li>等待系统自动申请并生成 SSL 证书（通常需要 2–15 分钟）</li></ol><p><img src="/pics/2026-2/GeneratingSSL.png"></p><p>证书生成完成后，域名状态变为有效，点击域名即可看到 Twikoo 的默认页面，表示绑定成功。</p><p><img src="/pics/2026-2/TwikooWebsite.png"></p><h2 id="4-修改主题配置文件"><a href="#4-修改主题配置文件" class="headerlink" title="4. 修改主题配置文件"></a>4. 修改主题配置文件</h2><hr><p>在 <code>_config.yourTheme.yml</code> 中修改以下两部分：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># 最多支持两个评论系统，第一个作为默认显示</span></span><br><span class="line">  <span class="comment"># 可选值：Valine / Waline / Twikoo / ...</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Twikoo</span>          <span class="comment"># 如需同时保留 Waline，可写：Twikoo,Waline</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span>           <span class="comment"># 按钮旁显示“评论”文字</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span>       <span class="comment"># 推荐开启：评论框进入视口后再加载，加快首屏速度</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span>          <span class="comment"># 文章页顶部显示评论数量</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span>  <span class="comment"># 首页文章卡片不显示评论数（可选）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Twikoo 配置</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">https://twikoo.example.com/</span>    <span class="comment"># 必须改为你绑定的完整二级域名，注意带 https:// 和结尾斜杠 /</span></span><br><span class="line">  <span class="attr">region:</span>               <span class="comment"># 一般留空，除非使用了腾讯云/阿里云函数</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：  </p><ul><li><code>envId</code> 必须是 <code>https://</code> 开头，且以 <code>/</code> 结尾，否则 Twikoo 会加载失败。  </li><li>修改配置文件后需重新生成静态文件。</li></ul><h2 id="5-本地测试"><a href="#5-本地测试" class="headerlink" title="5. 本地测试"></a>5. 本地测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure><p>启动本地服务后，访问任意文章页面，滚动到评论区，确认 Twikoo 评论框正常加载且可以提交评论。</p><p><img src="/pics/2026-2/TwikooTest.png"></p><p>完成以上步骤后，Twikoo 即可通过自定义二级域名正常工作。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> website </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Google Fonts为Hexo博客替换字体</title>
      <link href="/2026/02/07/%E7%94%A8Google-Fonts%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93/"/>
      <url>/2026/02/07/%E7%94%A8Google-Fonts%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%9B%BF%E6%8D%A2%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在-Google-Fonts-挑选字体"><a href="#1-在-Google-Fonts-挑选字体" class="headerlink" title="1. 在 Google Fonts 挑选字体"></a>1. 在 Google Fonts 挑选字体</h2><p>首先访问 <a href="https://fonts.google.com/">Google Fonts</a>，这里提供了数百种免费字体供您选择。</p><h3 id="筛选字体"><a href="#筛选字体" class="headerlink" title="筛选字体"></a>筛选字体</h3><ul><li>点击左侧的 <strong>Filters</strong> 按钮，您可以根据不同条件筛选字体</li><li>如果需要支持日文字符的字体，可以在语言筛选中选择 <strong>Japanese</strong></li></ul><p><img src="/pics/2026-2/FontsFilter.png" alt="字体筛选界面"></p><h3 id="获取字体代码"><a href="#获取字体代码" class="headerlink" title="获取字体代码"></a>获取字体代码</h3><ol><li>找到喜欢的字体后，点击字体卡片进入详情页</li><li>点击右上角的 <strong>“Get Font”</strong> 按钮将其添加到”购物车”</li></ol><p><img src="/pics/2026-2/GetFont.png" alt="获取字体"></p><ol start="3"><li>在右侧弹出的面板中，切换到 <strong>Embed</strong> 选项卡</li><li>复制提供的嵌入代码</li></ol><p><img src="/pics/2026-2/EmbedCode.png" alt="嵌入代码"></p><h2 id="2-修改主题配置文件"><a href="#2-修改主题配置文件" class="headerlink" title="2. 修改主题配置文件"></a>2. 修改主题配置文件</h2><h3 id="添加字体链接"><a href="#添加字体链接" class="headerlink" title="添加字体链接"></a>添加字体链接</h3><p>在 Hexo 主题的配置文件（通常是 <code>_config.yml</code> 或主题的配置文件）中，找到 <code>inject</code> 部分，将复制的代码粘贴到 <code>head</code> 项下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># 自定义 CSS 和字体链接</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;preconnect&quot;</span> <span class="string">href=&quot;https://fonts.googleapis.com&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;preconnect&quot;</span> <span class="string">href=&quot;https://fonts.gstatic.com&quot;</span> <span class="string">crossorigin&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">href=&quot;https://fonts.googleapis.com/css2?family=Yuji+Mai&amp;display=swap&quot;</span> <span class="string">rel=&quot;stylesheet&quot;&gt;</span></span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：YAML 对缩进要求严格，请确保每行开头的空格数一致。</p><h3 id="配置博客标题字体"><a href="#配置博客标题字体" class="headerlink" title="配置博客标题字体"></a>配置博客标题字体</h3><p>找到博客标题字体设置部分，将 Google Fonts 的字体名称添加到字体列表的最前面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 博客标题字体设置</span></span><br><span class="line"><span class="comment"># 影响左上角网站名称和主页居中显示的网站名称</span></span><br><span class="line"><span class="attr">blog_title_font:</span></span><br><span class="line">  <span class="attr">font_link:</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">Yuji</span> <span class="string">Mai,</span> <span class="string">PingFang</span> <span class="string">SC,</span> <span class="string">Hiragino</span> <span class="string">Sans</span> <span class="string">GB,</span> <span class="string">Microsoft</span> <span class="string">JhengHei,</span> <span class="string">Microsoft</span> <span class="string">YaHei,</span> <span class="string">sans-serif</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>我使用的是 “Yuji Mai” 字体，您可以选择自己喜欢的任何字体</li><li>字体栈的顺序很重要：浏览器会优先使用列表中的第一个可用字体</li><li>建议保留系统字体作为备选，确保在不同设备上都能正常显示</li></ul><h2 id="3-本地预览效果"><a href="#3-本地预览效果" class="headerlink" title="3. 本地预览效果"></a>3. 本地预览效果</h2><p>保存配置文件后，在终端执行以下命令清理缓存并启动本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo s;</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:4000</code> 查看字体更改效果：</p><p><img src="/pics/2026-2/WebsiteTitle.png" alt="网站标题效果"></p><p>如果标题字体已更新为新选择的字体，说明配置成功。</p><h2 id="4-部署到线上"><a href="#4-部署到线上" class="headerlink" title="4. 部署到线上"></a>4. 部署到线上</h2><p>确认本地效果满意后，执行以下命令生成静态文件并部署到线上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><h2 id="扩展应用与建议"><a href="#扩展应用与建议" class="headerlink" title="扩展应用与建议"></a>扩展应用与建议</h2><h3 id="应用到其他元素"><a href="#应用到其他元素" class="headerlink" title="应用到其他元素"></a>应用到其他元素</h3><p>同样的方法也可以用于修改其他文本元素的字体：</p><ul><li>正文字体 (<code>global_font</code>)</li><li>代码块字体 (<code>code_font</code>)</li><li>侧边栏字体等</li></ul><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><ol><li><strong>仅加载需要的字重</strong>：在 Google Fonts 中只选择实际使用的字重（如 Regular 400、Bold 700）</li><li><strong>使用 font-display: swap</strong>：确保文本在字体加载期间仍然可见</li><li><strong>考虑中文字体体积</strong>：中文字体文件较大，建议仅用于标题或少量文字</li></ol><h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><ul><li>如果字体未生效，检查浏览器开发者工具的 Network 选项卡，确认字体文件是否成功加载</li><li>确认字体名称拼写完全正确</li><li>清除浏览器缓存后重新加载页面</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过简单的四步操作，您就能为博客换上独具特色的字体。合理运用字体不仅能提升博客的视觉吸引力，还能增强阅读体验和品牌识别度。</p><p><strong>提示</strong>：您可以在 Google Fonts 同时添加多个字体，分别应用于标题、正文等不同元素，创造更丰富的版面层次感。</p><hr><p><em>示例中使用的是 <a href="https://fonts.google.com/specimen/Yuji+Mai">Yuji Mai</a> 字体，这是一款优雅的日文毛笔字体，适合用于标题展示。您可以根据自己的喜好选择其他字体。</em></p>]]></content>
      
      
      <categories>
          
          <category> Hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Flaticon帮你的网站找到一个好看的矢量图标</title>
      <link href="/2026/02/02/%E5%9C%A8flaticon%E5%B8%AE%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87/"/>
      <url>/2026/02/02/%E5%9C%A8flaticon%E5%B8%AE%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p><strong>操作流程：更换 Hexo 博客的 Favicon 图标</strong></p><p>本文介绍如何通过 Flaticon 获取图标并更换 Hexo 博客的网站图标 (Favicon)。</p><p><strong>1. 获取图标</strong><br>访问 <a href="https://www.flaticon.com/">Flaticon</a>，搜索并选择适合的图标。通常 PNG 格式即可满足网站使用需求。<br><img src="/pics/2026-2/chooseicon.png"></p><p>在下载页面选择 <strong>Free download</strong> 将其保存至本地。<br><img src="/pics/2026-2/freedownload.png"></p><p><strong>2. 更换配置</strong><br>将下载的图标文件置于博客的静态资源目录（例如 <code>source/icons/</code>）。随后在主题配置文件（如 <code>_config.anzhiyu.yml</code>）中更新 <code>favicon</code> 字段，指向该图标路径，并建议附上作者链接以便标注来源。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/icons/bank.png</span> <span class="comment"># 图标作者链接：https://www.flaticon.com/authors/icongeek26</span></span><br></pre></td></tr></table></figure><p><strong>3. 生效确认</strong><br>清除缓存并重新生成博客文件后，访问网站即可看到图标已更新。<br><img src="/pics/2026-2/favicon.png"></p><p><strong>版权声明</strong><br>本教程所示图标来源于 Flaticon 作者 <a href="https://www.flaticon.com/authors/icongeek26">Icongeek26</a>，仅作个人学习与演示之用，非商业用途。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> website </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adobe Express帮助你创建背景透明图片</title>
      <link href="/2026/02/02/Adobe-Express%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%88%9B%E5%BB%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E5%9B%BE%E7%89%87/"/>
      <url>/2026/02/02/Adobe-Express%E5%B8%AE%E5%8A%A9%E4%BD%A0%E5%88%9B%E5%BB%BA%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><strong>目的与背景</strong><br>在基于 Hexo 框架与 Anzhiyu 主题进行博客定制时，笔者希望保留侧边栏 <code>weixin_card</code> 组件的悬停翻转动效，但将其内容从微信公众号展示替换为自定义图像。本操作选用《Street Fighter》系列中的春丽（Chun-Li）与嘉米（Cammy）角色图片作为正面与背面展示内容。</p><p><strong>问题描述</strong><br>直接替换图像后，发现春丽图像背景未能完全透明，存在明显残留色块（见图1），导致与卡片背景融合不佳，影响视觉效果。</p><p><img src="/pics/2026-2/chunli1.png"></p><p><strong>解决方案</strong><br>使用 Adobe Express 在线工具进行背景移除操作，具体步骤如下：</p><ol><li>访问 <a href="https://new.express.adobe.com/">Adobe Express</a>；</li><li>选择“移除背景”功能；</li><li>上传原图并自动处理；</li><li>下载生成的透明背景 PNG 图像。</li></ol><p>处理界面与结果如下所示：</p><p><img src="/pics/2026-2/AdobeExpress.png"><br><img src="/pics/2026-2/paste.png"><br><img src="/pics/2026-2/result.png"><br><strong>部署与验证</strong><br>将处理后的图像替换至主题对应目录，在本地执行以下命令清除缓存并启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>刷新页面后，春丽图像已完整去除背景，正常嵌入卡片正面（见图2）：</p><p><img src="/pics/2026-2/chunli2.png"></p><p>随后对嘉米图像执行相同处理，并配置为卡片的 <code>back_face</code>（背面图像），实现悬停翻转时的图像切换效果（见图3）：</p><p><img src="/pics/2026-2/cammy.png"></p><p><strong>完成状态</strong><br>至此，原 <code>weixin_card</code> 组件的视觉样式与动效得以保留，内容已替换为定制图像，并具备完整的透明背景与双面翻转交互。</p><p><strong>版权声明</strong><br>本文所使用的春丽与嘉米角色图片来源于 Pixiv 画师 <strong>JuicePiggy16</strong>，该改造仅为个人博客美化使用，未涉及任何商业行为。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> website </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BrokerHub</title>
      <link href="/2026/01/29/BrokerHub/"/>
      <url>/2026/01/29/BrokerHub/</url>
      
        <content type="html"><![CDATA[<h1 id="0-BrokerHub-可以用来干什么？"><a href="#0-BrokerHub-可以用来干什么？" class="headerlink" title="0. BrokerHub 可以用来干什么？"></a>0. BrokerHub 可以用来干什么？</h1><hr><p><a href="https://github.com/math-zhuxy/BrokerHub">BrokerHub</a>一个由<strong>中山大学 HuangLab</strong> 开发的区块链协议验证平台，名为 <strong>BlockEmulator</strong>。</p><p>简单来说，<strong>它的用途是帮助研究人员或学生快速“模拟”和“验证”新的区块链技术</strong>，特别是“分片（Sharding）”和“共识协议”。它不是一个用来挖矿赚钱的工具，而是一个<strong>科研实验工具</strong>。</p><h2 id="0-1它可以帮你做这些事："><a href="#0-1它可以帮你做这些事：" class="headerlink" title="0.1它可以帮你做这些事："></a>0.1它可以帮你做这些事：</h2><ol><li><strong>模拟区块链运行</strong>：<br> 它可以在一台电脑（或多台）上模拟出一整条分片区块链网络，包含多个分片、多个节点。</li><li><strong>验证“跨分片”机制</strong>：<br> 它内置了两种主流的跨分片技术（BrokerChain 的 Broker 机制和 Monoxide 的 Relay 机制），你可以用它来测试不同分片间怎么处理交易。</li><li><strong>验证“共识”算法</strong>：<br> 它支持 PBFT（拜占庭容错）等共识协议，你可以修改代码来测试自己写的新共识算法效果如何。</li><li><strong>跑实验、出数据</strong>：<br> 它会自动记录 TPS（吞吐量）、延迟等核心指标，并输出成 CSV 文件。写论文或做研究时，可以直接用这些数据画图。</li><li><strong>支持智能合约</strong>：<br> 它包含了一个 VM 模块，可以在模拟链上跑 Solidity 智能合约。</li></ol><p><strong>总结</strong>：如果你在做区块链底层技术的研究（比如想改进分片效率、设计新共识），这个项目就是你的“测试沙盒”，让你不必从零写一条区块链就能验证你的想法。</p><h1 id="1-核心参数说明"><a href="#1-核心参数说明" class="headerlink" title="1. 核心参数说明"></a>1. 核心参数说明</h1><hr><p>项目的核心参数集中在 <code>BrokerHub/params/global_config.go</code> 文件中。</p><h2 id="1-1关键参数配置"><a href="#1-1关键参数配置" class="headerlink" title="1.1关键参数配置"></a>1.1关键参数配置</h2><table><thead><tr><th align="left">参数名</th><th align="left">默认值</th><th align="left">含义&#x2F;作用</th><th align="left">更新建议</th></tr></thead><tbody><tr><td align="left"><strong>Block_Interval</strong></td><td align="left"><code>1000</code></td><td align="left"><strong>出块间隔 (ms)</strong><br>每隔多少毫秒产生一个新区块</td><td align="left">想让出块更快就改小，模拟高延迟环境可改大</td></tr><tr><td align="left"><strong>MaxBlockSize_global</strong></td><td align="left"><code>500000</code></td><td align="left"><strong>区块最大容量</strong><br>一个区块里最多能装多少笔交易</td><td align="left">限制吞吐量上限的参数之一</td></tr><tr><td align="left"><strong>InjectSpeed</strong></td><td align="left"><code>5000</code></td><td align="left"><strong>交易注入速度 (TPS)</strong><br>模拟器每秒向网络发送多少笔交易</td><td align="left"><strong>最重要的负载参数</strong><br>想测极限性能就把这个调大，看系统能不能撑住</td></tr><tr><td align="left"><strong>TotalDataSize</strong></td><td align="left"><code>500000</code></td><td align="left"><strong>总交易数量</strong><br>整个实验一共跑多少笔交易后停止</td><td align="left">控制实验时长。如果跑太久，可以改小这个值</td></tr><tr><td align="left"><strong>BatchSize</strong></td><td align="left"><code>5000</code></td><td align="left"><strong>批处理大小</strong><br>Supervisor 每次读取并发送多少笔交易</td><td align="left">最好比 <strong>InjectSpeed</strong> 稍微大一点，保证发送顺畅</td></tr><tr><td align="left"><strong>ShardNum</strong></td><td align="left"><code>4</code></td><td align="left"><strong>分片数量</strong><br>整个网络被切分成几个片</td><td align="left">验证分片扩展性的核心参数</td></tr><tr><td align="left"><strong>NodesInShard</strong></td><td align="left"><code>4</code></td><td align="left"><strong>分片内节点数</strong><br>每个分片里有多少个节点参与共识</td><td align="left">节点越多，共识（PBFT）通常越慢</td></tr><tr><td align="left"><strong>BrokerNum</strong></td><td align="left"><code>1</code></td><td align="left"><strong>Broker 数量</strong><br>辅助跨分片的中间人节点数量</td><td align="left">仅在 broker 模式下生效</td></tr><tr><td align="left"><strong>DatWrite_path</strong></td><td align="left"><code>&quot;./result/&quot;</code></td><td align="left"><strong>数据输出路径</strong><br>实验结果 CSV 存哪儿</td><td align="left">一般不用改</td></tr></tbody></table><h2 id="1-2如何修改参数"><a href="#1-2如何修改参数" class="headerlink" title="1.2如何修改参数"></a>1.2如何修改参数</h2><ol><li><strong>打开配置文件</strong><ul><li>编辑 <code>global_config.go</code> 文件</li><li>找到对应的变量值直接修改数字</li></ul></li></ol><p><strong>修改代码后需要重新编译</strong></p><h1 id="2-如何运行BrokerHub"><a href="#2-如何运行BrokerHub" class="headerlink" title="2. 如何运行BrokerHub"></a>2. 如何运行BrokerHub</h1><hr><p>在 <code>Windows</code> 上大致分两步：</p><ol><li>编译</li><li>运行脚本</li></ol><h2 id="2-1编译"><a href="#2-1编译" class="headerlink" title="2.1编译"></a>2.1编译</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -o blockEmulator_Windows_Precompile.exe ./main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h2 id="2-2运行"><a href="#2-2运行" class="headerlink" title="2.2运行"></a>2.2运行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bat_shardNum=<span class="number">3</span>_NodeNum=<span class="number">4</span>_mod=Broker_b2e.bat</span><br></pre></td></tr></table></figure><p>直接执行 Windows 启动脚本（会自动启动 3 个分片、每分片 4 个节点并写入配置）。<br>执行过程如下。<br><img src="/pics/2026-2/vscodebrokerhub.png"></p><h1 id="3-BrokerHub-项目实验无法自动终止问题的排查与修复"><a href="#3-BrokerHub-项目实验无法自动终止问题的排查与修复" class="headerlink" title="3. BrokerHub 项目实验无法自动终止问题的排查与修复"></a>3. BrokerHub 项目实验无法自动终止问题的排查与修复</h1><h3 id="3-1问题描述"><a href="#3-1问题描述" class="headerlink" title="3.1问题描述"></a>3.1问题描述</h3><p>在运行 BrokerHub（BVM + Brokerchain 实验平台）时，执行启动脚本 bat_shardNum&#x3D;3_NodeNum&#x3D;4_mod&#x3D;Broker_b2e.bat 后，实验进程无法自动终止，Supervisor 日志中 epoch 计数持续递增（已超过 500），result 目录始终未生成。</p><h3 id="3-2系统停止机制分析"><a href="#3-2系统停止机制分析" class="headerlink" title="3.2系统停止机制分析"></a>3.2系统停止机制分析</h3><p>通过阅读源码，梳理出系统的正常关闭流程如下：</p><p>supervisor.go 中 <code>SupervisorTxHandling()</code> 的执行顺序为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MsgSendingControl() 返回</span><br><span class="line">    → 轮询 StopSignal.GapEnough()（等待连续收到 2×ShardNum 个空区块上报）</span><br><span class="line">        → 向所有节点发送 CStop 消息</span><br><span class="line">            → 调用 CloseSupervisor()，将测量数据写入 ./result/ 下的 CSV 文件</span><br></pre></td></tr></table></figure><p>其中 <code>StopSignal</code> 机制（见 supervisorStopModule.go）要求连续收到 <code>stopThreshold</code> 个空区块消息后才判定实验结束。任何非空区块都会将计数器重置为 0。</p><h2 id="3-3逐步排查过程"><a href="#3-3逐步排查过程" class="headerlink" title="3.3逐步排查过程"></a>3.3逐步排查过程</h2><h3 id="3-3-1-排查一：supervisor-go-中的调试代码"><a href="#3-3-1-排查一：supervisor-go-中的调试代码" class="headerlink" title="3.3.1 排查一：supervisor.go 中的调试代码"></a>3.3.1 排查一：supervisor.go 中的调试代码</h3><p>在 supervisor.go 发现无限循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在这里<strong>无限等待</strong>，即进入死循环，每秒 sleep 一次。<br>如果不注释掉注释，Supervisor 在这里会一直卡住，不会继续往下执行（不会发送 stop 信号，也不会关闭和写入结果文件）。</p><h3 id="3-3-2-排查二：MsgSendingControl-死循环（根因）"><a href="#3-3-2-排查二：MsgSendingControl-死循环（根因）" class="headerlink" title="3.3.2 排查二：MsgSendingControl() 死循环（根因）"></a>3.3.2 排查二：MsgSendingControl() 死循环（根因）</h3><p>启动脚本使用 <code>-m 4</code>，对应 <code>CommitteeMethod[4] = &quot;Broker_b2e&quot;</code>，实际加载的实现为 committee_brokerhub.go 中的 <code>BrokerhubCommitteeMod.MsgSendingControl()</code>。</p><p>对比能正常终止的 <code>BrokerCommitteeMod.MsgSendingControl()</code>（<code>-m 2</code>），后者从 CSV 文件读取交易，达到 <code>TotalDataSize</code> 后 <code>break</code> 退出。而 <code>BrokerhubCommitteeMod</code> 的实现包含<strong>两个无退出条件的死循环</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死循环 1：无限生成随机交易</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        bcm.hubParams.currentEpoch++</span><br><span class="line">        txs := bcm.generateRandomTxs()</span><br><span class="line">        bcm.txSending(...)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环 2：无限处理用户请求队列</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// ...处理队列...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>MsgSendingControl()</code> 永远不返回，<code>SupervisorTxHandling()</code> 中后续的停止逻辑永远无法执行。值得注意的是，代码中已定义了 <code>simulation_param.endedEpoch = 86</code> 字段，且在其他方法中存在对该字段的判断（第 473、806 行），但 <code>MsgSendingControl()</code> 中<strong>未引用</strong>此退出条件。</p><p><img src="/pics/2026-2/varEndedEpoch.png"></p><p><strong>修复措施</strong>：在 <code>MsgSendingControl()</code> 中引入 <code>endedEpoch</code> 退出机制。核心改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        bcm.hubParams.currentEpoch++</span><br><span class="line">        <span class="keyword">if</span> bcm.hubParams.currentEpoch &gt; bcm.hubParams.endedEpoch &#123;</span><br><span class="line">            <span class="built_in">close</span>(done)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...原有交易生成逻辑不变...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// 处理剩余队列后退出</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...原有队列处理逻辑不变...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 channel 信号在两个循环间协调退出，确保 epoch 达到上限后 <code>MsgSendingControl()</code> 正常返回。</p><h2 id="3-4验证"><a href="#3-4验证" class="headerlink" title="3.4验证"></a>3.4验证</h2><p>修复后重新编译运行，程序在约 86 个 epoch（约 3 分钟）后自动终止，result 目录正常生成，包含 Supervisor 测量指标 CSV 与 Broker 余额&#x2F;收益数据。<br><img src="/pics/2026-2/brokerhubresult.png"><br><img src="/pics/2026-2/BrokerHubResultExcel.png"></p><h2 id="3-5结论"><a href="#3-5结论" class="headerlink" title="3.5结论"></a>3.5结论</h2><p>本次问题的直接原因是 <code>BrokerhubCommitteeMod.MsgSendingControl()</code> 缺少退出条件，属于功能性缺陷。排查过程中虽也发现了<strong>调试代码残留</strong>的问题并予以修正。修复思路是复用已有的 <code>endedEpoch</code> 字段，以最小改动实现循环退出，保持与原有架构的一致性。</p><h1 id="4-极端参数压力测试学习法"><a href="#4-极端参数压力测试学习法" class="headerlink" title="4. 极端参数压力测试学习法"></a>4. 极端参数压力测试学习法</h1><hr><p>对<code>global_config.go</code>中参数进行极端取值。来观察系统行为，便于理解复杂系统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> params</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"></span><br><span class="line">    Block_Interval      = <span class="number">1</span> <span class="comment">// generate new block interval (ms)</span></span><br><span class="line"></span><br><span class="line">    MaxBlockSize_global = <span class="number">1</span> <span class="comment">// the block contains the maximum number of transactions</span></span><br><span class="line"></span><br><span class="line">    InjectSpeed         = <span class="number">1</span> <span class="comment">// the transaction inject speed</span></span><br><span class="line"></span><br><span class="line">    TotalDataSize       = <span class="number">1</span> <span class="comment">// the total number of txs</span></span><br><span class="line"></span><br><span class="line">    BatchSize           = <span class="number">1</span> <span class="comment">// supervisor read a batch of txs then send them, it should be larger than inject speed</span></span><br><span class="line"></span><br><span class="line">    BrokerNum           = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    NodesInShard        = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    ShardNum            = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    IterNum_B2E         = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    Brokerage           = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    DataWrite_path      = <span class="string">&quot;./result/&quot;</span> <span class="comment">// measurement data result output path</span></span><br><span class="line"></span><br><span class="line">    LogWrite_path       = <span class="string">&quot;./log&quot;</span>     <span class="comment">// log output path</span></span><br><span class="line"></span><br><span class="line">    KeyWrite_path       = <span class="string">&quot;./key&quot;</span></span><br><span class="line"></span><br><span class="line">    SupervisorAddr      = <span class="string">&quot;127.0.0.1:18800&quot;</span> <span class="comment">//supervisor ip address</span></span><br><span class="line"></span><br><span class="line">    FileInput           = <span class="string">&quot;./TXs.csv&quot;</span>       <span class="comment">//the raw BlockTransaction data path</span></span><br><span class="line"></span><br><span class="line">    NodeID              <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    ShardID             <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/pics/2026-2/BrokerHubCycling.png"><br>终端输出循环不停。</p><h2 id="4-1StopSignal-停止机制"><a href="#4-1StopSignal-停止机制" class="headerlink" title="4.1StopSignal 停止机制"></a>4.1StopSignal 停止机制</h2><p>supervisorStopModule.go 中的 <code>StopSignal</code> 维护一个计数器 <code>stopGap</code>，判定逻辑如下：</p><ul><li>每当 Supervisor 收到一个 <code>BlockInfoMsg</code> 且 <code>BlockBodyLength == 0</code>（空块），<code>stopGap++</code></li><li>每当收到一个 <code>BlockBodyLength &gt; 0</code>（非空块），<code>stopGap</code> <strong>归零</strong></li><li>当 <code>stopGap &gt;= stopThreshold</code>（值为 <code>2 × ShardNum = 6</code>）时，判定实验结束</li></ul><p>这意味着：<strong>必须连续收到 6 个来自各分片的空区块上报，中间不能被任何一个非空区块打断</strong>。</p><h3 id="4-2区块的完整生命周期"><a href="#4-2区块的完整生命周期" class="headerlink" title="4.2区块的完整生命周期"></a>4.2区块的完整生命周期</h3><p>要理解 StopSignal 何时能被满足，需要追踪从交易注入到区块上报的完整链路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Supervisor (MsgSendingControl)</span><br><span class="line">  ├── 每 2 秒生成一批随机交易</span><br><span class="line">  ├── dealTxByBroker() 拆分交易</span><br><span class="line">  │     ├── 同片交易 → 直接发送到对应分片</span><br><span class="line">  │     └── 跨片交易 → Broker 拆分为 Tx1 + Tx2（见下文）</span><br><span class="line">  └── txSending() → 按 InjectSpeed 批量注入各分片</span><br><span class="line">  </span><br><span class="line">各分片 PBFT 节点 (Propose 循环)</span><br><span class="line">  ├── 每隔 Block_Interval 毫秒触发一次</span><br><span class="line">  ├── GenerateBlock()</span><br><span class="line">  │     └── Txpool.PackTxs(50000) → 从交易池取出最多 50000 笔交易打包</span><br><span class="line">  ├── PBFT 三阶段共识（PrePrepare → Prepare → Commit）</span><br><span class="line">  └── HandleinCommit() → 区块上链 → 构造 BlockInfoMsg 发送给 Supervisor</span><br><span class="line">        └── BlockBodyLength = len(block.Body)</span><br></pre></td></tr></table></figure><h3 id="4-3Broker-机制产生的交易放大效应"><a href="#4-3Broker-机制产生的交易放大效应" class="headerlink" title="4.3Broker 机制产生的交易放大效应"></a>4.3Broker 机制产生的交易放大效应</h3><p>当 Supervisor 的 <code>dealTxByBroker()</code> 处理一笔跨分片交易时，会产生<strong>交易乘法效应</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始跨片交易 (Sender@Shard0 → Recipient@Shard1)</span><br><span class="line">     │</span><br><span class="line">     ├── Tx1: Sender → Broker（发到 Shard0）</span><br><span class="line">     ├── Tx2: Broker → Recipient（发到 Shard1）</span><br><span class="line">     └── AllocatedTx: Broker 余额调整交易（可能发到多个分片）</span><br></pre></td></tr></table></figure><p><strong>一笔原始交易至少衍生出 2-3 笔链上交易</strong>，而这些衍生交易的确认（<code>createConfirm</code>）又会在 <code>HandleBlockInfo</code> 回调中进一步触发 <code>handleBrokerType1Mes</code> → <code>txSending(tx1s)</code> 和 <code>handleBrokerType2Mes</code> → <code>txSending(tx2s)</code>，形成<strong>交易注入 → 上链 → 回调确认 → 再注入</strong>的闭环。</p><h3 id="4-4极端参数如何破坏停止条件"><a href="#4-4极端参数如何破坏停止条件" class="headerlink" title="4.4极端参数如何破坏停止条件"></a>4.4极端参数如何破坏停止条件</h3><p>当前参数为 <code>Block_Interval = 1</code>，<code>MaxBlockSize_global = 1</code>，<code>InjectSpeed = 1</code>。分析其所导致的时序关系：</p><h4 id="4-4-1-出块速率远超交易消化速率"><a href="#4-4-1-出块速率远超交易消化速率" class="headerlink" title="4.4.1 出块速率远超交易消化速率"></a>4.4.1 出块速率远超交易消化速率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Block_Interval = 1ms → 每个分片每毫秒尝试出一个块</span><br><span class="line">3 个分片 → 系统每毫秒最多产生 3 个区块</span><br><span class="line">每个区块最多容纳 1 笔交易（MaxBlockSize_global = 1，但实际 PackTxs 硬编码为 50000）</span><br></pre></td></tr></table></figure><p>注意：虽然 <code>MaxBlockSize_global = 1</code>，但 <a href="chain/blockchain.go#L1129">blockchain.go 第 1129 行</a> 中 <code>PackTxs</code> 的参数被<strong>硬编码为 50000</strong>，因此 <code>MaxBlockSize_global</code> 这个参数实际上不起作用。每次出块时会把交易池中的所有交易一次性打包。</p><h4 id="4-4-2-Broker-衍生交易形成持续注入流"><a href="#4-4-2-Broker-衍生交易形成持续注入流" class="headerlink" title="4.4.2 Broker 衍生交易形成持续注入流"></a>4.4.2 Broker 衍生交易形成持续注入流</h4><p>每个 epoch（每 2 秒），Supervisor 生成一批随机交易。其中跨片交易经 Broker 拆分后，产生 Tx1、Tx2、AllocatedTx 注入到不同分片。这些交易上链后，Supervisor 在 <code>HandleBlockInfo</code> 中收到区块上报，触发 <code>createConfirm</code> 回调，回调中又会通过 <code>txSending</code> 向分片注入新的交易（Tx2 的确认触发等）。</p><p>时序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t=0s    ：epoch 1 注入原始交易 → 衍生 Tx1、Tx2 注入各分片</span><br><span class="line">t=1ms   ：Shard0 出块，打包 Tx1 → 上报非空块 → stopGap 归零</span><br><span class="line">t=2ms   ：Shard1 出块，打包 Tx2 → 上报非空块 → stopGap 归零</span><br><span class="line">t=3ms   ：Shard0 出块，可能为空 → stopGap = 1</span><br><span class="line">t=4ms   ：Supervisor HandleBlockInfo 回调，生成确认交易 → 注入 Shard1</span><br><span class="line">t=5ms   ：Shard1 出块，打包确认交易 → 上报非空块 → stopGap 归零！</span><br><span class="line">t=2000ms：epoch 2 注入新一批交易 → 整个过程重复</span><br></pre></td></tr></table></figure><p><strong>关键问题</strong>：由于出块间隔仅 1ms，系统在 epoch 间隙期间并非空闲——之前 epoch 的衍生交易的确认回调会不断产生新交易，这些交易以极高频率（1ms 一个块）被打包上报。3 个分片交替上报非空块，使得 <code>stopGap</code> 计数器在到达 6 之前就被频繁重置。</p><h4 id="4-4-3-三分片交替出块的竞态效应"><a href="#4-4-3-三分片交替出块的竞态效应" class="headerlink" title="4.4.3 三分片交替出块的竞态效应"></a>4.4.3 三分片交替出块的竞态效应</h4><p>3 个分片独立出块，各自的出块时机不同步。即使某个分片的交易池已空，其他分片可能仍有衍生交易在处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间线：  --|------|------|------|------|------|---&gt;</span><br><span class="line">Shard0：  空   空   非空  空   空   空</span><br><span class="line">Shard1：  空   非空  空   空   非空  空    ← Broker 确认交易到达</span><br><span class="line">Shard2：  非空  空   空   非空  空   空    ← AllocatedTx 到达</span><br><span class="line">stopGap： 1    0!   0!   0!   1    0!    ← 永远无法累积到 6</span><br></pre></td></tr></table></figure><p>三个分片的非空块在时间轴上<strong>交错出现</strong>，使得连续空块窗口始终无法维持到 6 个。</p><h2 id="4-5合理参数为何能正常停止"><a href="#4-5合理参数为何能正常停止" class="headerlink" title="4.5合理参数为何能正常停止"></a>4.5合理参数为何能正常停止</h2><p>当 <code>Block_Interval = 1000</code>（1 秒）时：</p><ul><li>每个分片每秒只出一个块，给系统充足时间消化所有衍生交易</li><li>一个 epoch 的所有交易（原始 + 衍生 + 确认）在几个块内就能全部处理完</li><li>epoch 间隙（2 秒）内足够出 2 轮空块，3 个分片各出 2 个空块 &#x3D; 6 个空块上报</li><li><code>stopGap</code> 能够顺利累积到阈值 6，触发正常关闭</li></ul><h2 id="4-6结论"><a href="#4-6结论" class="headerlink" title="4.6结论"></a>4.6结论</h2><p>StopSignal 的设计前提是：<strong>交易注入有限、出块间隔合理、衍生交易能在若干轮出块内被完全消化</strong>。极端参数（1ms 出块）打破了这一前提——Broker 的交易放大效应 + 确认回调的循环注入 + 多分片交替出块，使得系统中始终存在零星的非空块，<code>stopGap</code> 计数器永远无法连续累积到阈值。</p><p>三个分片的非空块在时间轴上<strong>交错出现</strong>，使得连续空块窗口始终无法维持到 6 个。</p><h2 id="4-7合理参数为何能正常停止"><a href="#4-7合理参数为何能正常停止" class="headerlink" title="4.7合理参数为何能正常停止"></a>4.7合理参数为何能正常停止</h2><p>当 <code>Block_Interval = 1000</code>（1 秒）时：</p><ul><li>每个分片每秒只出一个块，给系统充足时间消化所有衍生交易</li><li>一个 epoch 的所有交易（原始 + 衍生 + 确认）在几个块内就能全部处理完</li><li>epoch 间隙（2 秒）内足够出 2 轮空块，3 个分片各出 2 个空块 &#x3D; 6 个空块上报</li><li><code>stopGap</code> 能够顺利累积到阈值 6，触发正常关闭</li></ul><h2 id="4-8结论"><a href="#4-8结论" class="headerlink" title="4.8结论"></a>4.8结论</h2><p>StopSignal 的设计前提是：<strong>交易注入有限、出块间隔合理、衍生交易能在若干轮出块内被完全消化</strong>。极端参数（1ms 出块）打破了这一前提——Broker 的交易放大效应 + 确认回调的循环注入 + 多分片交替出块，使得系统中始终存在零星的非空块，<code>stopGap</code> 计数器永远无法连续累积到阈值。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BrokerHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
